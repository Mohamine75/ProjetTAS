let te1 = Var "x"                   (* x *)
let te2 = Abs ("x", Var "x")         (* λx. x *)
let te3 = App (Var "f", Var "x")     (* f x *)

(* Environnement d'exemple *)
let env1 = [("x", Varp "T1"); ("f", Arr (Varp "T2", Varp "T3"))] (* [(x, T1); (f, T2 -> T3)] *)

(* Test 1 : Générer l'équation pour le terme Var "x" *)
let res1 = genere_equa te1 (Varp "T") env1  
(* Résultat attendu: [(T1, T)] *)

(* Test 2 : Générer l'équation pour le terme λx. x *)
let res2 = genere_equa te2 (Arr (Varp "T1", Varp "T2")) []  
(* Résultat attendu: [(T1, T1)] *)

(* Test 3 : Générer l'équation pour le terme f x *)
let res3 = genere_equa te3 (Varp "T") env1  
(* Résultat attendu: [(T2 -> T3, T); (T2, T1)] *)

let eq1 = [(Varp "T", Varp "T")]  (* T = T *)
let res1 = uni_step eq1
(* Résultat attendu: [] (l'équation est triviale et donc simplifiée) *)
let eq2 = [(Varp "T1", Varp "T2")]  (* T1 = T2 *)
let res2 = uni_step eq2
(* Résultat attendu: [] (les deux variables seront substituées et l'équation sera supprimée) *)
let eq3 = [(Arr (Varp "T1", Varp "T2"), Arr (Varp "T3", Varp "T4"))]  (* T1 -> T2 = T3 -> T4 *)
let res3 = uni_step eq3
(* Résultat attendu: [(T1, T3); (T2, T4)] (les sous-types doivent être comparés) *)

let eq4 = [(Varp "T1", Arr (Varp "T1", Varp "T2"))]  (* T1 = T1 -> T2 *)
let res4 = try Some (uni_step eq4) with Failure msg -> None
(* Résultat attendu: None (échec d'unification à cause de l'occurrence check) *)

let eq5 = [(Nat, Varp "T1")]  (* Nat = T1 *)
let res5 = uni_step eq5
(* Résultat attendu: [(Nat, T1)] (T1 sera substitué par Nat) *)
let eq6 = [(Varp "T1", Nat); (Nat, Varp "T2")]  (* Test avec des types incluant Nat *)
let res6 = try Some (uni_step eq6) with Failure msg -> None
(* Résultat attendu : None, car unification de Nat avec un type variable devrait échouer *)

---------- Pour résoudre systeme : 
(* Exemple d'équations de typage *)
let eq1 = [(Varp "T1", Varp "T2")] ;;
let eq2 = [(Varp "T1", Arr (Varp "T2", Varp "T3")); (Arr (Varp "T2", Varp "T3"), Varp "T4")] ;;
let eq3 = [(Varp "T1", Nat); (Nat, Varp "T2")] ;;
let eq4 = [(Varp "T1", Nat); (Nat, Varp "T1")] ;;  (* Équation triviale, doit passer *)
let eq5 = [(Arr (Nat, Varp "T1"), Arr (Varp "T2", Nat))] ;;  (* Unification de fonctions *)

(* Tester la fonction de résolution du système d'équations *)
let res1 = resoudre_systeme eq1 ;;
let res2 = resoudre_systeme eq2 ;;
let res3 = resoudre_systeme eq3 ;;
let res4 = resoudre_systeme eq4 ;;
let res5 = resoudre_systeme eq5 ;;

(* Affichage des résultats *)
let () =
  print_endline "Résultats des tests de resoudre_systeme :";
  print_endline ("Résultat 1 : " ^ (match res1 with Some _ -> "Succès" | None -> "Échec"));
  print_endline ("Résultat 2 : " ^ (match res2 with Some _ -> "Succès" | None -> "Échec"));
  print_endline ("Résultat 3 : " ^ (match res3 with Some _ -> "Succès" | None -> "Échec"));
  print_endline ("Résultat 4 : " ^ (match res4 with Some _ -> "Succès" | None -> "Échec"));
  print_endline ("Résultat 5 : " ^ (match res5 with Some _ -> "Succès" | None -> "Échec"));;


(* Termes à tester *)
let te1 = Var "x" ;;  (* Variable *)
let te2 = Abs ("x", Var "x") ;;  (* Fonction identité : λx.x *)
let te3 = App (Var "f", Var "x") ;;  (* Application f x *)

(* Environnement d'exemple *)
let env1 = [("x", Varp "T1"); ("f", Arr (Varp "T2", Varp "T3"))] ;;  (* [(x, T1); (f, T2 -> T3)] *)

(* Tester la fonction d'inférence de type *)
let typ1 = infere_type te1 env1 ;;
let typ2 = infere_type te2 [] ;;  (* Lambda sans environnement *)
let typ3 = infere_type te3 env1 ;;

(* Affichage des résultats *)
let () =
  print_endline "Résultats des tests d'inference de type :";
  print_endline ("Type de te1 (Var x) : " ^ (match typ1 with Some ty -> "Type trouvé" | None -> "Non typable"));
  print_endline ("Type de te2 (λx.x) : " ^ (match typ2 with Some ty -> "Type trouvé" | None -> "Non typable"));
  print_endline ("Type de te3 (f x) : " ^ (match typ3 with Some ty -> "Type trouvé" | None -> "Non typable"));